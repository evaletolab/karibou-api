
var mongoose = require('mongoose')
  , Schema = mongoose.Schema
  , ObjectId = Schema.ObjectId
  , validate = require('mongoose-validate')
	, passport = require('passport')
  , _ = require('underscore');
	
//var	bcrypt = require('bcrypt');

 /* Enumerations for field validation */
 var EnumGender="homme femme".split(' ');
 var EnumProvider="twitter facebook goolge persona local".split(' ');
 var EnumRegion=config.shop.region.list;


// validate URL
validate.url = function (value) {
  try {
   check(value).len(10, 200).regex(/(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/);
  } catch(err) {
   return false;
  }
  return true;
};

// validate postal code
validate.postal = function (value) {
  try {
   check(value).isAlpha();   
  } catch(err) {
   return false;
  }
  return true;
};
 

 // Normalized profile information conforms to the contact schema established by Portable Contacts.
 // http://portablecontacts.net/draft-spec.html#schema
 // MongoError: E11000 duplicate key error index: karibou-devel.users.$email.address_1  dup key: { : null }
 var UserSchema = new Schema({
    /* A unique identifier for the user, as generated by the service provider.  */
    id    : {type:Number, required: true, unique: true},   

    /* The provider which with the user authenticated (facebook, twitter, etc.) */
    provider: {type:String, required: true, unique: false, enum: EnumProvider}, 
    
    email:{
      address:{type : String, index:true, unique: true, sparse: true, required : false, 
        validate:[validate.email, 'adresse email invalide']
      },
      status:Schema.Types.Mixed,
    },
    
    /* The name of this user, suitable for display.*/
    displayName:String, 
    name: {
        familyName: String,
        givenName: String
    },
    
    birthday: Date,
    gender: {type:String, enum:EnumGender},
    tags: [String],
    url:{type:String, validate:[validate.url,'Invalide URL format or lenght']},
    
    phoneNumbers: [{
        number:{ type: String },
        what:{ type: String }
    }],
    
    photo: String,
    
    addresses: [{
          name: { type: String, required : true, lowercase: true, trim: true },
          note: { type: String, trim: true },
          floor: { type: String, trim: true, required : true },
          streetAdress: { type: String, required : true, lowercase: true, trim: true },
          location: { type: String, required : true, trim: true },
          region: { type: String, required : true, trim: true, default:"Genève", enum: EnumRegion },
          postalCode: { type: String, required : false /**,
            validate:[validate.postal,'Invalide postal code'] **/
          },
          primary:{ type: Boolean, required : true, default:false},
          geo:{
            lat:{type:Number, required: true},
            lng:{type:Number, required: true}
          }
    }],
    
    /* preferred products*/
    likes: [{type: Schema.Types.ObjectId, ref : 'Products'}],
    
    /* The available Shop for this user */
    shops: [{type: Schema.Types.ObjectId, ref : 'Shops'}],
    
    
    /* link user and orders */    
    orders : [{type: String}],
    
    /* make user valid/invalid */
    status:{type:Boolean, default: true},
    
    /* password and creation date (for local session only)*/    
    created:{type:Date, default: Date.now},
		salt: { type: String, required: false },
		hash: { type: String, required: false },   
		roles: Array,
    rank: String
});

/**
UserSchema.pre("save",function(next, done) {
    var self = this;
    if (!self.email || true) {
      done();
      return next();
    }
    this.model("Users").findOne({'email.address' : self.email.address},function(err, user) {
        if(err) {
            done(err);
        } else if(user) {
            self.invalidate("email.address","L'address email doit être unique");
            done(new Error("L'address email doit être unique"));
        } else {
            done();
        }
    });
    next();
});

  **/
/**
 * validation functions
 */
//UserSchema.path('XYZ').validate(function (value) {
//  return /male|female|homme|femme/i.test(value);
//}, 'Invalid gender');

UserSchema.statics.findOrCreate=function(u,callback){
	var Users=this.model('Users');

  //TODO this is a simple implementation that auth persona to match local email 
  if (u.provider==='persona'){
    var persona= delete u.provider;
  }
  Users.findOne(u, function(err, user){
    if(!user){
      if (u.provider==='local'){
        return callback("The system can not automaticaly create user for local provider");
      }
      
      if (!u.id && u['email.address']){
        u.id=u['email.address'].hash()
        u["email.status"]=true;
      }
      if(persona){u['provider']='persona'}
      var newuser=new Users(u);
      newuser.save(function(err){
        //if ( err && err.code === 11000 )
        callback(err,newuser);
      });
    }else{
      callback(err, user);
    }
  });

};


UserSchema.post('save', function () {
  // if (this._wasNew) console.error('new!');
  // else console.error('updated!');
});

UserSchema.statics.findByEmail = function(email, success, fail){
  return this.model('Users').findOne({'email.address':email}).populate('shops').populate('likes').exec(function(err,user){
    if(err){
      fail(err)
    }else{
      success(user);
    }
  });
};

UserSchema.statics.findByToken = function(token, success, fail){
  return this.model('Users').findOne({provider:token}).populate('shops').populate('likes').exec(function(err,user){
    if(err){
      fail(err)
    }else{
      success(user);
    }
  });
};

UserSchema.methods.isAdmin = function () {
  return this.hasRole('admin');
};

UserSchema.methods.hasRole = function (role) {
 for (var i = 0; i < this.roles.length; i++) {
   if (this.roles[i] === role) {
     // if the role that we are chekign matches the 'role' we are
     // looking for return true
     return true;
   }

 };
 // if the role does not match return false
 return false;
};

UserSchema.methods.addLikes = function(product, callback){
  var u=this;
  u.likes.push(product);
  u.save(callback);
};

UserSchema.methods.removeLikes = function(product, callback){
  var u=this;
  u.likes.pop(product);
  u.save(callback);
};

//
// like product
UserSchema.statics.like=function(id,sku,callback){
  var Users=this.model('Users'), Products=this.model('Products');  

  return Users.findOne({id:id}).populate('likes').exec(function (err, user) {

    if(err){
      return callback(err);
    }
    if(!user){
      return callback("Utilisateur inconnu");
    }

    // remove like?
    var product=_.find(user.likes, function(p){return p.sku==sku});
    if (product){
        return user.removeLikes(product,callback)        
    }

    return Products.findOneBySku(sku,function(err,product){
      return user.addLikes(product,callback)          
    })

  });
};

UserSchema.methods.display = function(){
  if (this.displayName)return this.displayName;
  if (this.name && (this.name.givenName || this.name.familyName)) {
    return this.name.givenName+' '+this.name.familyName
  }
  if (this.id){
    return this.id+'@'+this.provider;
  }
    
  return 'Anonymous';
};

UserSchema.statics.login = function(email, password, callback){
  console.log("login",email, password);
};


/**
 * local registration
 * - virtual field for password (mapped to salt && hash)
 * - verify password 
 * - authenticate
 * - register
 */  
UserSchema.virtual('password').get(function () {
  return this._password;
});

UserSchema.virtual('password').set(function (password) {
  this._password = password;
// more safe
//  var salt = this.salt = bcrypt.genSaltSync(10);
//  this.hash = bcrypt.hashSync(password, salt);
  var crypto= require('crypto');
  var salt  = this.salt = crypto.randomBytes(32).toString('base64'); 
  // FIXME hash method are not safe, use bcrypt 
  this.hash = crypto.createHash('sha1').update(password).digest("hex")
});

UserSchema.method('verifyPassword', function(password, callback) {
  var hash=require('crypto').createHash('sha1').update(password).digest("hex");

  //
  // for security reason password hash is removed from the memory!
  if(this.hash==="true"){
    this.model('Users').findOne({ id: this.id }).exec(function(err,user){
      return   callback(null,hash===user.hash);        
    })    
  }else{
    callback(null,hash===this.hash);    
  }
//  bcrypt.compare(password, this.hash, callback);
});


UserSchema.statics.authenticate=function(email, password, callback) {

  return this.model('Users').findOne({ 'email.address': email }).populate('shops').populate('likes').exec(function(err,user){
      if (err) { return callback(err); }

      // on user is Null
      if (!user) { 
        return callback("L'utilisateur ou le mot de passe est incorrect", false); 
      }
      
      // verify passwd
      user.verifyPassword(password, function(err, passwordCorrect) {
        if (err) { return callback(err); }
        if (!passwordCorrect) { return callback(null, false); }
        return callback(null, user);
      });
    });
};



UserSchema.statics.register = function(email, first, last, password, confirm, callback){
	var Users=this.model('Users');
	//error("TODO, we cannot register a user without matching a common provider (twitter, google, fb, flickr)");
	
	if (password !==confirm){
	  callback(("password confirmation is not identical"));
	  return;
	}
	
	//hash password (see virtual methods )
	//var pwd=require('crypto').createHash('sha1').update(password).digest("hex");
	
    
  /* The name of this user, suitable for display.*/
  //FIXME email.hash() should be replaced by (id++)+10000000
	// create a new customer
	var user=new Users({
	    id:email.hash(),
      displayName:first+" "+last, 
      name: {
          familyName: last,
          givenName: first
      },
      email:{address:email,status:new Date()},
			provider:"local",
			password:password,
			created:new Date()
	});

	//save it
	user.save(function(err){	  
	  //FIXME manage the duplicate address ( err && err.code === 11000 )
		callback(err, user);
	});
};

UserSchema.statics.updateStatus=function(id, status,callback){
	var Users=this.model('Users');	

  return Users.findOne(id).populate('shops').populate('likes').exec(function (err, user) {
    if(err){
      return callback(err);
    }
    if(!user){
      return callback("Utilisateur inconnu");
    }
    user.status=status;
    
    user.save(function (err) {
      //
      // update all shops
      require('async').forEach(user.shops, function(shop,cb){
          shop.updateStatus(status,function(err){
            cb(err)
          });        
      },function(err){
        callback(err,user);
      });    
    });
  
  });
}





//
// update shop content
UserSchema.statics.update=function(id, u,callback){
	var Users=this.model('Users');	

  return Users.findOne(id).populate('shops').populate('likes').exec(function (err, user) {
    if(err){
      return callback(err);
    }
    if(!user){
      return callback("Utilisateur inconnu");
    }

    if (u.name&&u.name.familyName) user.name.familyName=u.name.familyName;
    if (u.name&&u.name.givenName) user.name.givenName=u.name.givenName;
    user.displayName=user.name.givenName+" "+user.name.familyName;
    
    //
    // check is email has changed (require a validation)
    if (u.email&&u.email.address) {
      if (user.email.address!==u.email.address)
        user.email.status=new Date();
      user.email.address=u.email.address;
    }
    //
    // update the adress
    var primary=0;
    if (u.addresses) {
      user.addresses=[]
      u.addresses.forEach(function(address){
        if(address.primary)primary++;
        user.addresses.push(address)
      });
    }
    
    if(primary>1){
      return callback("Il ne peut pas y avoir deux adresses principales");
    }

    //
    // update the phones
    if (u.phoneNumbers) {
      user.phoneNumbers=[]
      u.phoneNumbers.forEach(function(phone){
        user.phoneNumbers.push(phone)
      });
    }

    //
    // DO NOT update the validation here
    // ONLY ADMIN CAN DO THAT
    if(u.status!=user.status){
    }
    
    user.save(function (err) {
      //if ( err && err.code === 11000 )
        
      return callback(err,user);
    });
  });
};
UserSchema.set('autoIndex', config.mongo.ensureIndex);
module.exports = mongoose.model('Users', UserSchema);



